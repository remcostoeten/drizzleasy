# Design Document

## Overview

This design addresses critical production readiness issues in Drizzleasy by implementing robust error handling, connection management, schema validation, and developer experience improvements. The design maintains the library's core philosophy of simplicity while adding essential production-grade features that prevent common pitfalls in small CRUD applications.

## Architecture

### Core Components Enhancement

```
┌─────────────────────────────────────────────────────────────┐
│                    Enhanced Drizzleasy                     │
├─────────────────────────────────────────────────────────────┤
│  Connection Manager    │  Schema Validator  │  Error Handler │
│  - Pool Management     │  - Type Checking   │  - Categorization│
│  - Retry Logic         │  - Field Validation│  - Sanitization  │
│  - Health Checks       │  - Migration Hints │  - Dev/Prod Mode │
├─────────────────────────────────────────────────────────────┤
│  Enhanced CRUD Operations                                   │
│  - Transaction Support │ Performance Monitor │ ID Generator   │
│  - Batch Processing    │ - Query Timing     │ - Smart Detection│
│  - Optimistic Locking  │ - N+1 Detection    │ - Fallback Logic │
├─────────────────────────────────────────────────────────────┤
│                    Drizzle ORM Core                         │
└─────────────────────────────────────────────────────────────┘
```

## Components and Interfaces

### 1. Enhanced Connection Manager

**Purpose:** Provide reliable database connections with proper error handling and retry logic.

```typescript
interface IConnectionManager {
  initialize(config: ConnectionConfig): Promise<DatabaseConnection>
  getConnection(name?: string): DatabaseConnection
  healthCheck(): Promise<HealthStatus>
  close(): Promise<void>
}

interface ConnectionConfig {
  url: string | EnvironmentConfig
  options?: {
    maxRetries?: number
    retryDelay?: number
    poolSize?: number
    timeout?: number
    healthCheckInterval?: number
  }
}

interface HealthStatus {
  status: 'healthy' | 'degraded' | 'unhealthy'
  connections: Record<string, ConnectionHealth>
  lastCheck: Date
}
```

**Key Features:**
- Connection pooling with configurable limits
- Automatic retry with exponential backoff
- Health monitoring and graceful degradation
- Credential sanitization in error messages
- Environment-specific configuration validation

### 2. Schema Validation System

**Purpose:** Provide comprehensive schema validation with helpful error messages.

```typescript
interface ISchemaValidator {
  validateSchema(schema: any): ValidationResult
  validateTableAccess(tableName: string): ValidationResult
  validateFieldAccess(tableName: string, fieldName: string): ValidationResult
  suggestSimilar(input: string, available: string[]): string[]
}

interface ValidationResult {
  valid: boolean
  errors: ValidationError[]
  warnings: ValidationWarning[]
  suggestions: string[]
}

interface ValidationError {
  type: 'MISSING_TABLE' | 'MISSING_FIELD' | 'TYPE_MISMATCH' | 'CONSTRAINT_VIOLATION'
  message: string
  field?: string
  table?: string
  suggestions: string[]
}
```

**Key Features:**
- Runtime schema validation
- Fuzzy matching for typo suggestions
- Type compatibility checking
- Migration guidance
- Development vs production validation modes

### 3. Enhanced Error Handling

**Purpose:** Provide categorized, actionable error messages with appropriate detail levels.

```typescript
interface IErrorHandler {
  categorizeError(error: unknown): CategorizedError
  sanitizeError(error: CategorizedError, mode: 'development' | 'production'): CategorizedError
  createUserFriendlyMessage(error: CategorizedError): string
}

interface CategorizedError extends TEnhancedError {
  category: 'CONNECTION' | 'VALIDATION' | 'PERMISSION' | 'CONSTRAINT' | 'TIMEOUT' | 'UNKNOWN'
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'
  userMessage: string
  developerMessage: string
  actionable: boolean
  retryable: boolean
}
```

**Key Features:**
- Error categorization for programmatic handling
- Environment-aware error detail levels
- Actionable error messages with resolution steps
- Credential sanitization
- Structured logging support

### 4. Smart ID Generation

**Purpose:** Provide reliable ID generation that adapts to different database schemas.

```typescript
interface IIdGenerator {
  detectIdStrategy(table: any): IdStrategy
  generateId(strategy: IdStrategy, context?: IdContext): string | number
  validateIdField(table: any, field: string): IdValidation
}

interface IdStrategy {
  type: 'auto_increment' | 'uuid' | 'nanoid' | 'custom'
  generator?: () => string | number
  validation?: (id: any) => boolean
}

interface IdValidation {
  valid: boolean
  type: 'numeric' | 'text' | 'uuid'
  autoGenerated: boolean
  constraints: string[]
}
```

**Key Features:**
- Automatic ID strategy detection
- Database-specific ID generation
- Validation of ID constraints
- Fallback strategies for generation failures
- Support for composite keys (with clear limitations)

### 5. Performance Monitor

**Purpose:** Monitor query performance and provide optimization suggestions.

```typescript
interface IPerformanceMonitor {
  trackQuery(query: string, duration: number, metadata: QueryMetadata): void
  detectSlowQueries(threshold: number): SlowQuery[]
  detectNPlusOne(queries: QueryLog[]): NPlusOnePattern[]
  generateOptimizationSuggestions(): OptimizationSuggestion[]
}

interface QueryMetadata {
  table: string
  operation: 'create' | 'read' | 'update' | 'delete'
  recordCount: number
  hasLimit: boolean
  hasIndex: boolean
}

interface OptimizationSuggestion {
  type: 'ADD_LIMIT' | 'ADD_INDEX' | 'USE_BATCH' | 'USE_PAGINATION'
  query: string
  impact: 'LOW' | 'MEDIUM' | 'HIGH'
  description: string
  example: string
}
```

**Key Features:**
- Query timing and analysis
- N+1 query detection
- Performance optimization suggestions
- Development mode warnings
- Query pattern analysis

### 6. Transaction Manager

**Purpose:** Provide simple transaction support for data consistency.

```typescript
interface ITransactionManager {
  withTransaction<T>(operations: (tx: Transaction) => Promise<T>): Promise<T>
  createSavepoint(name: string): Promise<Savepoint>
  rollbackToSavepoint(savepoint: Savepoint): Promise<void>
  detectDeadlock(error: any): boolean
}

interface Transaction {
  create: typeof crud.create
  read: typeof crud.read
  update: typeof crud.update
  destroy: typeof crud.destroy
  commit(): Promise<void>
  rollback(): Promise<void>
}
```

**Key Features:**
- Simple transaction wrapper
- Automatic rollback on errors
- Deadlock detection and retry
- Savepoint support for complex operations
- Transaction timeout handling

## Data Models

### Enhanced Configuration Model

```typescript
interface DrizzleasyConfig {
  database: ConnectionConfig
  schema: SchemaConfig
  performance: PerformanceConfig
  errors: ErrorConfig
  development: DevelopmentConfig
}

interface SchemaConfig {
  autoLoad: boolean
  validationMode: 'strict' | 'lenient'
  migrationHints: boolean
  typeChecking: boolean
}

interface PerformanceConfig {
  queryTimeout: number
  slowQueryThreshold: number
  enableMonitoring: boolean
  warnOnMissingLimits: boolean
  maxBatchSize: number
}

interface ErrorConfig {
  mode: 'development' | 'production'
  sanitizeCredentials: boolean
  includeStackTrace: boolean
  logLevel: 'error' | 'warn' | 'info' | 'debug'
}
```

### Enhanced Result Types

```typescript
interface EnhancedResult<T> extends TEnhancedResult<T> {
  performance?: {
    queryTime: number
    recordCount: number
    optimizationSuggestions: OptimizationSuggestion[]
  }
  validation?: {
    warnings: ValidationWarning[]
    suggestions: string[]
  }
}
```

## Error Handling

### Error Categories and Responses

1. **Connection Errors**
   - Database unreachable → Retry with backoff
   - Invalid credentials → Clear setup instructions
   - Pool exhausted → Queue with timeout

2. **Schema Errors**
   - Missing table → Suggest similar tables
   - Missing field → Show available fields
   - Type mismatch → Provide conversion guidance

3. **Validation Errors**
   - Required fields → List all missing fields
   - Constraint violations → User-friendly explanations
   - Data type errors → Show expected vs actual

4. **Performance Warnings**
   - Missing limits → Suggest pagination
   - Slow queries → Optimization recommendations
   - N+1 patterns → Batch operation suggestions

### Error Message Templates

```typescript
const ERROR_TEMPLATES = {
  MISSING_TABLE: {
    user: "Table '{table}' not found. Did you mean '{suggestion}'?",
    developer: "Table '{table}' not found in schema. Available tables: {tables}",
    action: "Check your table name spelling or update your schema."
  },
  CONNECTION_FAILED: {
    user: "Unable to connect to database. Please check your connection.",
    developer: "Connection failed: {sanitizedError}",
    action: "Verify DATABASE_URL and network connectivity."
  }
}
```

## Testing Strategy

### Unit Testing
- Error categorization and sanitization
- ID generation strategies
- Schema validation logic
- Performance monitoring calculations
- Connection retry mechanisms

### Integration Testing
- Database connection scenarios
- Transaction rollback behavior
- Error handling across different databases
- Performance monitoring accuracy
- Schema loading from various configurations

### End-to-End Testing
- Complete CRUD workflows with error scenarios
- Multi-environment configuration switching
- Performance optimization suggestions
- Transaction consistency under load
- Error message clarity and actionability

### Performance Testing
- Connection pool behavior under load
- Query performance monitoring accuracy
- Memory usage with large result sets
- Transaction throughput and deadlock handling
- Error handling overhead

## Implementation Phases

### Phase 1: Core Infrastructure
- Enhanced connection manager
- Basic error categorization
- Schema validation framework
- Configuration system

### Phase 2: Developer Experience
- Error message improvements
- Performance monitoring
- Development mode features
- Validation suggestions

### Phase 3: Production Features
- Transaction support
- Advanced retry logic
- Performance optimizations
- Monitoring integrations

### Phase 4: Advanced Features
- Migration guidance
- Query optimization
- Advanced error recovery
- Comprehensive logging

## Migration Strategy

### Backward Compatibility
- All existing APIs remain unchanged
- New features are opt-in by default
- Gradual migration path for enhanced features
- Clear deprecation notices for any changes

### Configuration Migration
- Automatic detection of old configuration formats
- Migration utilities for complex setups
- Validation of migrated configurations
- Rollback support for configuration changes

## Security Considerations

### Credential Protection
- Automatic sanitization of connection strings in logs
- Environment variable validation
- Secure storage recommendations
- Audit trail for configuration changes

### Error Information Disclosure
- Production mode sanitizes sensitive data
- Development mode provides full details
- Configurable information disclosure levels
- Structured logging without credentials